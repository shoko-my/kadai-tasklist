
Lesson13
メッセージボードの構築
難易度123
Lesson 13Chapter 1
学習の目標
ここから、今までに学んだ知識を総動員してWebアプリケーションを構築します。

このレッスンではJava Servletによる最初のWebアプリケーションとして、メッセージボードを作成します。少しずつアプリケーションを作成しながら、サーブレットならびにJSPの機能や概念をどのようにしてアプリケーション開発に活かすかを説明します。

メッセージボードは、内容を入力して送信すると、用意されたボードにメッセージが書き込まれる単純なWebアプリです。

00_01

00_02

00_03

もし、今までに出てきた操作や文法がわからなくなった場合は、ぜひ以前のレッスンの内容を読んでみてください。また、開発途中で原因不明のトラブルが起きたときは、Lesson 11 の「eclipseでWebアプリケーション開発をする上での注意点」 を参考にしてみてください。

本レッスンの主な内容
今回作成するWebアプリケーションの概要
eclipseでのプロジェクトの作成と初期設定
RESTに沿ったデータ処理機能の作成
index（一覧表示）
new（新規登録）
create（挿入処理）
show（詳細画面）
edit（編集画面）
update（更新処理）
delete（削除処理）
より良いアプリケーションにするTips
データが無かった場合に表示内容を変える
CSSによる画面の装飾
フラッシュメッセージ
ページネーション
バリデーション
参考資料：HerokuでWebアプリケーションを公開する
本レッスンのゴール
メッセージボードのWebアプリケーションが完成していること
Java/サーブレット/JSPを使ってWebアプリケーションを作る方法について理解していること
本レッスンの前提条件
eclipse（Pleiades）のインストールと必要な設定が完了していること（事前準備）
Webアプリケーションの画面（ブラウザに表示される内容）の作り方を習得していること（HTML/CSS）
Javaの基本的な命令の書き方について習得していること（Javaプログラミング基礎）
Javaで命令を制御する方法を習得していること（制御構文）
オブジェクトの概念およびオブジェクト指向プログラミングについて理解していること（オブジェクト指向プログラミング1,2）
MySQLをインストールできていること（データベース（DB））
MySQLおよびSQL言語の基本的な使い方を習得していること（データベース（DB））
Mavenの基本的な使い方を習得していること（JDBC1）
JDBCドライバを使ってJavaとDBを連携させる方法を習得していること（JDBC1）
O/Rマッピングの概念ならびにHibernateの使い方を習得していること（JDBC2）
インターネット上のWebアプリケーションの仕組みについて理解していること（Webアプリケーションの仕組み）
GitのインストールならびにGitHubへのアカウント登録が完了していること（Git/GitHub）
GitならびにGitHubの基本的な使い方を習得していること（Git/GitHub）
Lesson 13Chapter 2
準備：eclipseからGit Bash／ターミナルを呼び出す
メッセージボードと次の日報管理システムでは、少しずつアプリケーションを構築します。その際、コーディングが複雑化してアプリケーションが正常に動作しなくなり、その原因も突き止められないという場合に、正常に動作していたときの状態へ簡単に戻せるよう、要所要所でGitにコミットします。

Gitを操作するためにGit Bash／ターミナルを使うことになりますが、eclipse上からGit Bashやターミナルを起動でき、さらに今回作成するアプリケーションのプロジェクトフォルダに最初から移動している状態になっていると便利です。

そこで、画面上部、再生ボタンの横にある、カバンの絵が入ったアイコンのボタンからGit Bash／ターミナルを起動できるようにします。

01

まずは再生＋カバンのマーク（外部ツール）の右にある▼をクリック→外部ツールの構成をクリックしてください。

02

外部ツール構成の画面が表示されます。左側のリストの中にある「プログラム」にマウスカーソルを合わせて右クリック→「新規」を選びます。

03

メインタブの設定内容はWindowsかMacかで若干異なります。

04

Windowsの場合

名前は「Git Bash」とします。

メインタブを開き、以下のように入力してください。
- ロケーション：C:\Program Files\Git\git-bash.exe
- 作業ディレクトリー：${project_loc}

Macの場合

名前は「ターミナル」とします。

メインタブを開き、以下のように入力してください。
- ロケーション：/usr/bin/open
- 引数：-a Terminal ${project_loc}

 ・コピペだと文字化けが発生することがあるため、手入力してください
・Git Bash（ターミナル）を開き、cdコマンドで該当のディレクトリに移動する方法でもかまいません
メインタブの設定が完了したら共通タブを開き、「お気に入りのメニューに表示」の中の「外部ツール」にチェックを入れて「適用」ボタンをクリックして設定を保存してください。適用したらいったん「閉じる」で大丈夫です。

05

メッセージボードのプロジェクトを作成した後、 プロジェクト・エクスプローラーで「message_board」の何らかの要素を選択状態にした上で 外部ツールの▼をクリック→「1　Git Bash（ターミナル）」をクリックしてください。最初からメッセージボードのプロジェクトのフォルダにいる状態でGit Bash／ターミナルが開きます。

まだすぐには使わないので、いったんGit Bash／ターミナルは閉じてください。

なお、message_board の要素を選択状態にするのを忘れると、エラーの画面になるので注意しましょう。

Lesson 13Chapter 3
eclipseプロジェクトの作成
eclipseの準備が整いましたので、動的Webプロジェクトを作成しましょう。

Lesson 13Chapter 3.1
動的Webプロジェクトの作成
画面上部のメニューからファイル→新規→動的Webプロジェクトと進みます。

プロジェクトの設定は、今回は以下のようにしてください。

1ページ目

プロジェクト名：message_board
デフォルト・ロケーションを使用：チェックを入れる
ターゲット・ランタイム：Tomcat8 (Java8)
動的webモジュール バージョン：3.1
構成：Tomcat8 (Java8) デフォルト構成
EARメンバーシップ：未入力のまま
ワーキングセット：未入力のまま
2ページ目

（変更点なし）

3ページ目

コンテキスト・ルート：message_board（プロジェクト名そのまま）
コンテンツ・ディレクトリー：WebContent
web.xml デプロイメント記述子の生成：チェックを外す
あとはそのままで「完了」へ進めてもらって構いません。

Lesson 13Chapter 3.2
Gitの初期設定を行う
.gitignore を作成する
プロジェクトを作成したところで、この段階のプロジェクト一式をGitにコミットしておきましょう。最初に、余計なファイルまでコミットしないようにするための .gitignore を作成します。プロジェクト・エクスプローラーで message_board のプロジェクト名を右クリック→新規→ファイルで .gitignore を新規作成してください。エディタでファイルを開いたら、以下の内容をコピペで書き写して保存してください。なお、下記の内容は、GitHubが公式で公開している .gitignore のうちJavaとMavenに関しての .gitignore をベースにしています。

# Compiled class file
*.class

# Package Files #
*.jar
*.war
*.ear

# Maven
target/

# eclipse
.classpath
.project
.settings/
build/

# OS Files
Thumbs.db
.DS_Store
.gitignore をプロジェクト・エクスプローラーに表示させる
.gitignore はデフォルトではプロジェクト・エクスプローラーに表示されませんので、表示されるように設定を変更しておきましょう。プロジェクト・エクスプローラー右上にある白い▽をクリック→ビューのカスタマイズをクリックします。

05_01

「可能なカスタマイズ」画面が表示されます。「フィルター」タブにある .*リソース のチェックを外して「OK」をクリックしてください。

05_02

これでプロジェクト・エクスプローラーに .gitignore が表示されます。

05_03

Gitにコミットする
保存できたら、本レッスンのチャプター2 で紹介したようにプロジェクト・エクスプローラーで message_board プロジェクト内の何らかの要素を選択状態にした上で、外部ツール（カバンの絵が入ったボタン）からGit Bash（ターミナル）を起動し、以下のコマンドを実行してGitにコミットしましょう。また、ブランチ名も master から main に変更しておきましょう。

$ git init
$ git add .
$ git commit -m "Initial commit"
$ git branch -M main
Lesson 13Chapter 3.3
Mavenプロジェクトへ変換
JDBCドライバやJSTLなどをプロジェクトに取り込むため、message_boardでMavenを使えるようにしましょう。

プロジェクト・エクスプローラーで message_board を右クリック→構成→Mavenプロジェクトへ変換を選びます。

設定項目は、グループIdを jp.example に変更する以外はデフォルトで構いません。そのまま完了まで進めてください。

Lesson 13Chapter 3.4
必要な外部ライブラリのインストール
pom.xmlを開きます。依存関係タブから設定を4つ追加してください。

1. JDBCドライバ
- グループId：mysql
- アーティファクトId：mysql-connector-java
- バージョン：5.1.45

2. Hibernate
- グループId：org.hibernate
- アーティファクトId：hibernate-core
- バージョン：5.2.13.Final

3. JSTL(1つめ)
- グループId：org.apache.taglibs
- アーティファクトId：taglibs-standard-impl
- バージョン：1.2.5

4. JSTL(2つめ)
- グループId：javax.servlet.jsp.jstl
- アーティファクトId：javax.servlet.jsp.jstl-api
- バージョン：1.2.1

入力できたら保存します。

 PCのスペックにもよりますが、ステータスバーが表示されている場合、eclipse画面右下の表示が100%完了に落ち着くまで待ちましょう（いつまでも動いているようでしたらeclipseを終了の上、再起動してください）。
Gitにコミットする
さきほど作成したpom.xmlをコミットしておきましょう。

$ git add .
$ git commit -m "Add pom.xml"
Lesson 13Chapter 4
最初のサーブレットを作ってTomcatの動作を確認する
とりあえずサーブレットを1つ用意して、Tomcatが正常に動作するか確認しましょう。

Lesson 13Chapter 4.1
サーブレットの作成
プロジェクト・エクスプローラーの “Javaリソース” 内にある src で controllers パッケージを作成してください。そのあとで src を右クリック→新規→「サーブレット」を選びます。

設定項目は以下の内容にしてください。以下に記載がない項目についてはデフォルトのままで構いません。

1ページ目

パッケージ名（eclipseの表示上は Javaパッケージ）：controllers
クラス名：IndexServlet
2ページ目

URLマッピング： /IndexServlet を /index に変更する
3ページ目

doPostのチェックのみ外し、あとはそのまま
ここまで設定できたら「完了」をクリックします。すると、以下の内容で IndexServlet が作られます。

src/controllers/IndexServlet.java

package controllers;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class IndexServlet
 */
@WebServlet("/index")
public class IndexServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    /**
     * @see HttpServlet#HttpServlet()
     */
    public IndexServlet() {
        super();
        // TODO Auto-generated constructor stub
    }

    /**
     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // TODO Auto-generated method stub
        response.getWriter().append("Served at: ").append(request.getContextPath());
    }

}
Lesson 13Chapter 4.2
アプリケーションサーバ（Tomcat8）の設定と起動
message_boardアプリケーションがTomcat上で動作するように設定します。

画面下部の「サーバー」タブを開いてください。前のレッスンで first_webapp を作成しているので、すでに「ローカル・ホストのTomcat8」が表示されています。これを右クリックして「追加および除去」をクリックしてください。

06

使用可能（左側）の選択ボックスにある message_board を選択して「追加＞」をクリックすると、構成済み（右側）の選択ボックスに message_board が移動します。移動したことを確認して「完了」をクリックしてください。

07

ここまでできたらTomcatを起動します。画面下部「サーバー」で「ローカル・ホストのTomcat8」を右クリック→「開始（再開）」を選択してください。サーバー欄の表示に 始動済み, 同期済み と出ていることを確認しましょう。

Chrome、もしくはeclipseの内部ブラウザで、

http://localhost:8080/message_board/index
にアクセスして、「Served at: /message_board」と表示されていればOKです！

Gitにコミットする
IndexServlet.java をコミットしておきましょう。

$ git add .
$ git commit -m "Add IndexServlet.java"
Lesson 13Chapter 5
MySQLとHibernateのセットアップ
次にデータベースの設定を行います。データベースについて忘れてしまった方は Lesson7 データベース（DB） から復習してください。

Lesson 13Chapter 5.1
MySQLに新しいデータベースを作成する
先にMySQLの設定を行います。

まず、新しいターミナル（コマンドプロンプト）のウィンドウを開き、そこに mysql -u root -p を実行し、rootパスワードを入力してログインしてください。

 mysql -u root -p を実行したら以下のような文章が表示された、という場合はMySQLのサーバソフトウェアが起動していないことが原因なので、Lesson7のチャプター7「MySQLのインストール」の記載内容を参考にMySQLを起動してください。
ERROR 2002 (HY000): Can't connect to local MySQL server through socket '...(省略)...' (2)
ログインしたら、以下のSQLを順番に実行しましょう。コンソールから1行ずつ入力でも、ファイルを作って実行するのでも、どちらでも構いません。

CREATE DATABASE message_board DEFAULT CHARACTER SET utf8;（message_boardアプリ用のデータベースを作成）
CREATE USER 'mesuser'@'localhost' IDENTIFIED BY 'mespass';（データベースに接続するアカウントを登録）
GRANT ALL PRIVILEGES ON message_board.* TO 'mesuser'@'localhost';（さきほど登録したアカウントにINSERTやUPDATE等の実行ができる権限を付与）
message_board データベースと、message_board データベースに全権限をもつ mesuser アカウント（パスワード： mespass）が作成されます。

Lesson 13Chapter 5.2
Hibernateのセットアップ
MySQL上に message_board データベースの作成が行えたら、次はeclipse上の message_board プロジェクト上でHibernateをセットアップします。

つまり、動的Webプロジェクト上から message_board データベースにアクセスできるように設定します（動的Webプロジェクトでも操作や設定方法は同じなので、復習したい方は Lesson9 JDBC2 の内容を確認してみてください）。

まず、プロジェクト・エクスプローラーで message_board を右クリック→構成→JPAプロジェクトへ変換をクリックします。

プロジェクト・ファセットの画面では初期状態のままで（最低限、「Java（バージョン：1.8）」「JPA（バージョン：2.1）」「動的webモジュール（バージョン：3.1）」にチェックが入っていて、バージョンも記載どおりの状態であれば）大丈夫です。内容を確認して「次へ」をクリックしてください。

JPAファセットの画面では、以下の内容を入力してください。

プラットフォーム：Generic 2.1
JPA実装：ライブラリー構成を無効
接続：なし
永続化クラス管理：注釈付きクラスを persistence.xml に記述
以上で「完了」をクリックします。

警告表示が気になるなら、プロジェクト・エクスプローラーで message_board を右クリック→プロパティー→JPA→エラー/警告まで進み、プロジェクト固有の設定を可能にする へチェックを入れた上で、「指定された接続がないプロジェクト：無視」にして「適用」してください。それ以外はそのままで、プロパティーを閉じましょう。

次に persistence.xml に各種設定を追加します。プロジェクト・エクスプローラーで message_board →JPAコンテンツ→persistence.xmlを開いてください。

一般タブで、以下の内容を入力します。

名前：message_board
永続化プロバイダー：
org.hibernate.jpa.HibernatePersistenceProvider
接続タブを開いて　トランザクション・タイプ：リソース・ローカルに変更し、さらに “JDBC接続プロパティー” で次のように入力してください。

ドライバー：com.mysql.jdbc.Driver
URL：
jdbc:mysql://localhost/message_board?useSSL=false&useUnicode=true&characterEncoding=utf8
ユーザー：mesuser
パスワード：mespass
スキーマ生成タブを開き、下記の内容を入力してください。

Database action：作成
Scripts generation：デフォルト（なし）
プロパティータブを開き、以下の情報を追加します。

名前：hibernate.dialect
値：org.hibernate.dialect.MySQL5Dialect
名前：hibernate.show_sql
値：true
名前：hibernate.format_sql
値：true
以上の設定が完了したらファイルを保存してください。

ここで、 message_board データベースにはまだテーブルが作成されていないことに気づかれている方もいらっしゃるかと思いますが、大丈夫です。

上記のpersistence.xml のスキーマ生成の設定でテーブルの自動作成を設定しています。それが、Database action を「作成」にしたことです。これにより、テーブルが自動作成（CREATE TABLE文が発行）されます。後ほど確認しましょう。

なお、今回はテーブルを自動作成にしていますが、実際の業務ではテーブルを手動で作成して利用することも多くありますので、テーブルの新規作成（CREATE TABLE）についても復習しておいてください。

Lesson 13Chapter 5.3
モデル（DTO）の作成
message_boardデータベース（テーブル）と message_board プロジェクトの連携が設定できましたので、必要なデータを格納するクラス（Model）を作成していきましょう。

Javaリソース→srcの中に新たに models パッケージを作成し、その中に Message クラスを作成（DTOになるクラス）を作成します。main()メソッドは不要です。

src/models/Message.java

package models;

import java.sql.Timestamp;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "messages")
public class Message {
    @Id
    @Column(name = "id")
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column(name = "title", length = 255, nullable = false)
    private String title;

    @Column(name = "content", length = 255, nullable = false)
    private String content;

    @Column(name = "created_at", nullable = false)
    private Timestamp created_at;

    @Column(name = "updated_at", nullable = false)
    private Timestamp updated_at;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public Timestamp getCreated_at() {
        return created_at;
    }

    public void setCreated_at(Timestamp created_at) {
        this.created_at = created_at;
    }

    public Timestamp getUpdated_at() {
        return updated_at;
    }

    public void setUpdated_at(Timestamp updated_at) {
        this.updated_at = updated_at;
    }
}
それぞれのカラムの意味をまとめておきます。

カラム名    用途  データ型    補足
id  メッセージID 数値型 自動採番
title   メッセージのタイトル  文字列型    必須入力
content メッセージの内容    文字列型    必須入力
created_at  作成日時    日時型 必須入力
updated_at  更新日時    日時型 必須入力
このとき、@Column アノテーションの ( ..., nullable = false) で、必須入力が設定されています（nullable、つまりnullを許容するか否かの設定で、true だとnullを許容し、falseだと許容しないことになります）。

また、そのほかのアノテーションについてまとめておきます。

アノテーション 概要  指定先 備考
@GeneratedValue 主キー値を自動採番すること   フィールド   省略可能
@NamedQueries（後述）   複数のNamedQueryをまとめたもので、NamedQueryをカンマで区切り指定  クラス 省略可能
@NamedQuery（後述） 主キー以外の項目などで検索し、複数件の結果を取得したい場合に定義する  クラス 省略可能
なお、上記の Message クラスの内容を保存すると、「クラス “models.Message” は管理されていますが、persistence.xml ファイルにリストされていません」という内容のエラーが表示されます。

そこで、persistence.xml を再度開き、一般タブの右側にある「管理クラス」にMessageを追加してください。パターン入力欄に Message と入力すれば、”一致する項目” の欄に Message - models と出てくるので、それを選択して「OK」をクリックし、persistence.xmlを保存してください。

persistence.xmlの保存と同時に、Message で表示されていたエラーは無くなります。

Lesson 13Chapter 5.4
DAO（DBUtil）の作成
次にDAOに相当する DBUtil クラスを utils パッケージ（新規で用意）の中に作成します。main()メソッドは不要です。なお、こちらは、パッケージ名が異なるものの Lesson9 JDBC2の「6.4 Hibernateを使ってDBからデータを取得する」 で作成したものと同じです。

src/utils/DBUtil.java

package utils;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public class DBUtil {
    private static final String PERSISTENCE_UNIT_NAME = "message_board";
    private static EntityManagerFactory emf;

    public static EntityManager createEntityManager() {
        return getEntityManagerFactory().createEntityManager();
    }

    private static EntityManagerFactory getEntityManagerFactory() {
        if(emf == null) {
            emf = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME);
        }

        return emf;
    }
}
Gitにコミットする
ここまで作成したデータベース関連のファイルをコミットしておきましょう。

$ git add .
$ git commit -m "Add database files"
 本来であれば MySQL のユーザ名・パスワードが記載されている persistence.xml はGit管理の対象にするべきファイルではありません。GitHubなどにpushすることを考慮した場合、全員にユーザ名とパスワードが知れ渡ってしまうからです。

今回は学習用途としてのプロジェクトですので、あまり細かいことは考えず、persistence.xml をGit管理の対象としています。
ポイントの確認
ここまでの内容がどんな内容だったか、改めて振り返っておきましょう。
一度に網羅する必要はありません。まずは下記の項目を理解できていれば大丈夫です。

・WebアプリケーションでのHibernateの使い方内容を確認する
Lesson 13Chapter 6
index（一覧表示） の作成
では、ここから、前のレッスンで紹介したRESTの概念に沿ってメッセージボードのアプリケーションを作っていきましょう。index new create show edit update destroy の以上7つのサーブレットを作成します。

まだデータベースには1件もデータが入っていませんが、まずは index から作成していきましょう。こちらはさきほど作成した IndexServlet をコントローラとします。 IndexServlet はデータベースから複数のメッセージ情報を取得して一覧表示するサーブレットです。

なお、一件取得する find() メソッドに近い形で複数件のデータを取得するメソッドは存在していませんので、JPQL と呼ばれる少し特殊なSQL文（SELECT文）を Message クラスに用意する必要があります。このとき、 @NamedQueries アノテーションと @NamedQuery アノテーションを利用します。

では Message クラスに “一覧表示するデータを取得するためのJPQL” を追記しましょう。 @Entity アノテーションのある行と @Table アノテーションが書かれた行の間に以下の @NamedQueries アノテーションの記述を追加してください。

src/models/Message.java

// ...（中略）...
@Entity
@NamedQueries({
    @NamedQuery(
        name = "getAllMessages",
        query = "SELECT m FROM Message AS m ORDER BY m.id DESC"
    )
})
@Table(name = "messages")
// ...（中略）...
このとき、以下のクラスのimportが必要になります。確認してください。

import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
@NamedQuery アノテーションを使い、SELECT m FROM Message AS m ORDER BY m.id DESC というSELECT文に getAllMessages という名前をつけたのが上記の記述の内容です。SELECT m は通常のSQLでいうところの SELECT * と同じです。このあたりがJPQLの特殊な点になります。

次に、IndexServlet クラスの doGet メソッドを以下のように修正してください。

src/controllers/IndexServlet.java

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        EntityManager em = DBUtil.createEntityManager();

        List<Message> messages = em.createNamedQuery("getAllMessages", Message.class).getResultList();
        response.getWriter().append(Integer.valueOf(messages.size()).toString());

        em.close();
    }
このとき、以下のクラスのimportが必要です。

import java.util.List;
import javax.persistence.EntityManager;
import models.Message;
import utils.DBUtil;
さきほどJPQLの文につけた名前 getAllMessages を createNamedQuery メソッドの引数に指定してあげることで、データベースへの問い合わせを実行できます。

その問い合わせ結果を getResultList() メソッドを使ってリスト形式で取得します。データベースに保存されたデータはHibernateによって自動で Message クラスのオブジェクトになってこのリストの中に格納されるので便利です。

さあ、Tomcatを再起動して、

http://localhost:8080/message_board/index
にアクセスして動作確認してみましょう。画面に「0」と表示されればOKです。この0は、データの登録件数で、

response.getWriter().append(Integer.valueOf(messages.size()).toString());
の実行結果になります。この一連のメソッドの意味は知らなくて大丈夫です。繰り返しですが、データを1件も登録していないので、この結果（0）で問題ありません。

なお、

http://localhost:8080/message_board/index
にアクセスした時点でMySQLの message_board データベースに messages テーブルが追加されました。

eclipseの画面下部「コンソール」で CREATE TABLE 文が発行されているのを確認できます（本レッスンの「5.2 Hibernateのセットアップ」にある persistence.xml のスキーマ生成の設定 ）。

Hibernate:

    create table messages (
       id integer not null auto_increment,
        content varchar(255) not null,
        created_at datetime not null,
        title varchar(255) not null,
        updated_at datetime not null,
        primary key (id)
    ) engine=MyISAM
それと併せて、ターミナル（コマンドプロンプト）からMySQLにログインして、下記の内容を確認すると良いでしょう。

mysql> use message_board;

Database changed
mysql> show tables;
+-------------------------+
| Tables_in_message_board |
+-------------------------+
| messages                |
+-------------------------+
1 row in set (0.00 sec)

mysql> select * from messages;
Empty set (0.00 sec)
Gitにコミットする
ここまで作成したデータベース関連のファイルをコミットしておきましょう。

$ git add .
$ git commit -m "Add getAllMessages"
Lesson 13Chapter 7
EncodingFilterを追加する
次にデータベースへの登録機能を作りますので、このタイミングで、文字化け防止の「おまじない」を追加しましょう。

文字化け防止は、すべてのサーブレットで行う必要があるため、サーブレットを作成するたびに行うとなると面倒です。
そこで、Lesson11 サーブレット/JSPの「13 フィルタ」 で作成した EncodingFilter を message_board でも導入することにします。

filters パッケージ（新規で用意）の中に EncodingFilter というクラス名で新規フィルタを作成してください。

すべてのサーブレットに EncodingFilter を適用するので、”フィルタの作成” ウィンドウの2ページ目で設定する “フィルター・マッピング” は /*（URLパターン）にします。なお、フィルタのことを忘れてしまった場合は Lesson11 サーブレット/JSPの「13 フィルタ」 を復習しましょう。

EncodingFilter のファイルの内容は以下のとおりです。パッケージ名が異なるものの、Lesson11で作成したものと同じです。

src/filters/EncodingFilter.java

package filters;

import java.io.IOException;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebFilter;

/**
 * Servlet Filter implementation class EncodingFilter
 */
@WebFilter("/*")
public class EncodingFilter implements Filter {

    /**
     * Default constructor.
     */
    public EncodingFilter() {

    }

    /**
     * @see Filter#destroy()
     */
    public void destroy() {

    }

    /**
     * @see Filter#doFilter(ServletRequest, ServletResponse, FilterChain)
     */
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        request.setCharacterEncoding("UTF-8");
        response.setCharacterEncoding("UTF-8");

        chain.doFilter(request, response);
    }

    /**
     * @see Filter#init(FilterConfig)
     */
    public void init(FilterConfig fConfig) throws ServletException {

    }

}
Lesson 13Chapter 8
new（新規登録） の作成
では、controllers パッケージに NewServlet というクラスを追加しましょう。このクラスは、新規登録処理（SQLでいうと、INSERT文）を行うコントローラになります。

設定項目は以下の内容にしてください。以下に記載がない項目についてはデフォルトのままで構いません。

1ページ目

パッケージ名：controllers
クラス名：NewServlet
2ページ目

URLマッピング： /NewServlet を /new に変更する
3ページ目

doPostのチェックのみ外し、あとはそのまま
作成したサーブレットのファイルの doGet を以下のように記述します。

src/controllers/NewServlet.java（doGetのみ抜粋）

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        EntityManager em = DBUtil.createEntityManager();

        // Messageのインスタンスを生成
        Message m = new Message();

        // mの各フィールドにデータを代入
        String title = "taro";
        m.setTitle(title);

        String content = "hello";
        m.setContent(content);

        Timestamp currentTime = new Timestamp(System.currentTimeMillis());     // 現在の日時を取得
        m.setCreated_at(currentTime);
        m.setUpdated_at(currentTime);

        // データベースに保存
        em.getTransaction().begin();
        em.persist(m);
        em.getTransaction().commit();

        // 自動採番されたIDの値を表示
        response.getWriter().append(Integer.valueOf(m.getId()).toString());

        em.close();
     }
このとき、以下のクラスのimportが必要です。

import java.sql.Timestamp;
import javax.persistence.EntityManager;
import models.Message;
import utils.DBUtil;
Message m = new Message(); で Message のインスタンスを生成した後、自動採番されるID以外のフィールドに値をセットし、em.persist(m); でデータベースに保存します。em.getTransaction().commit(); はデータの新規登録を確定（コミット）させる命令です。

ここまで書いて保存できたら、Tomcatを再起動して、

http://localhost:8080/message_board/new
にアクセスしてください。画面に「1」と表示されればOKです。この「1」は、データベースへ1件登録された際に auto_increment で自動採番された id 列の値になります。また、eclipseのコンソール画面には、以下のようなSQL文が表示されており、このINSERT文が実行されたことになります。

Hibernate:
    insert
    into
        messages
        (content, created_at, title, updated_at)
    values
        (?, ?, ?, ?)
values のところが ? となっていますが、INSERT文が実行される際に taro や hello が動的に当てはめられていますので安心してください。実際に1件登録されたことをターミナルで確認しておくと良いでしょう。

mysql> select * from messages;
+----+---------+---------------------+-------+---------------------+
| id | content | created_at          | title | updated_at          |
+----+---------+---------------------+-------+---------------------+
|  1 | hello   | 2018-03-01 16:45:32 | taro  | 2018-03-01 16:45:32 |
+----+---------+---------------------+-------+---------------------+
1 row in set (0.00 sec)
Gitにコミットする
ここまでの内容をGitにコミットしましょう。

$ git add .
$ git commit -m "Add NewServlet.java"
Lesson 13Chapter 9
indexとnew のビューの作成
IndexServlet も NewServlet も、とりあえずデータベースへのアクセスを試しただけでした。RESTの概念に従うなら index はデータの一覧を表示する画面にし、 new は新規登録用のフォームを表示する画面にするべきです。また、MVCの「ビュー」を作成していません。

そこで、サーブレットのコードを調整しつつ、ビューになるJSPを用意して、index と new を完成させましょう。

Lesson 13Chapter 9.1
レイアウトファイルの作成
画面は index new show edit の4つで必要になります。各画面で共通している部分（ヘッダーやフッターなど）は「共通のひな形（サイトデザインの大枠）」として用意しておくと修正が楽になります。そこで、共通のひな形の役割をもつ「レイアウトファイル」を作成しましょう。

WebContent/WEB-INF の中に views、さらにその中に layout というフォルダを作り、layout の中に app.jsp を作成してください。エディタで以下のように app.jsp を修正してください。

WebContent/WEB-INF/views/layout/app.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="UTF-8">
        <title>メッセージボード</title>
    </head>
    <body>
        <div id="wrapper">
            <div id="header">
                <h1>メッセージボード アプリケーション</h1>
            </div>
            <div id="content">
                ${param.content}
            </div>
            <div id="footer">
                by Taro Kirameki.
            </div>
        </div>
    </body>
</html>
このファイルの内容が大枠となり、 ${param.content} と書かれた部分に各ページのビューの内容が入ります。

Lesson 13Chapter 9.2
indexのビューを作成
IndexServlet の doGet から、ビューとして /WEB-INF/views/messages/index.jsp を呼び出します。まずはサーブレットの方の修正から。

src/controllers/IndexServlet.java

protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    EntityManager em = DBUtil.createEntityManager();

    List<Message> messages = em.createNamedQuery("getAllMessages", Message.class).getResultList();

    em.close();

    request.setAttribute("messages", messages);

    RequestDispatcher rd = request.getRequestDispatcher("/WEB-INF/views/messages/index.jsp");
    rd.forward(request, response);
}
このとき、以下のクラスのimportが必要です。

import javax.servlet.RequestDispatcher;
データベースから取得したメッセージ一覧（messages）をリクエストスコープにセットし、index.jsp を呼び出しています。

続いて index.jsp を作成します。views フォルダの中に messages フォルダを作成した上で、JSPファイルを作ってください。

WebContent/WEB-INF/views/messages/index.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<c:import url="../layout/app.jsp">
    <c:param name="content">
        <h2>メッセージ一覧</h2>
        <ul>
            <c:forEach var="message" items="${messages}">
                <li>
                    <a href="${pageContext.request.contextPath}/show?id=${message.id}">
                        <c:out value="${message.id}" />
                    </a>
                    ：<c:out value="${message.title}"></c:out> &gt; <c:out value="${message.content}" />
                </li>
            </c:forEach>
        </ul>

        <p><a href="${pageContext.request.contextPath}/new">新規メッセージの投稿</a></p>

    </c:param>
</c:import>
<c:import> を使うことで、url 属性に指定したファイルの内容をその位置で読み込むことができます。<c:param name="content"> と書いたタグの中の記述内容が、app.jsp の ${param.content} のところに当てはまります。

このあたりを復習したい方は Lesson11 サーブレット/JSPの「12.1 主なJSTLタグまとめ」にある「HTMLのテンプレート化」 を参照してください。

また、

<c:out value="${pageContext.request.contextPath}" />
と記述することで、その部分が自動的に /message_board というコンテキストパスの文字列に置き換わります。コンテキストパスの設定を変更してもJSPファイルに修正が必要なくなるので、コンテキストパスは固定の文字列より上記の書き方をオススメします。

なお、<c:url> タグを使ってURLの指定を行っても自動で /message_board のコンテキストパスの文字列が挿入されます。たとえば、

<a href="${pageContext.request.contextPath}/new">新規メッセージの投稿</a>
これは以下のように記載しても同じ内容になります。

<a href="<c:url value='/new' />">新規メッセージの投稿</a>
動作確認
話が飛びましたので戻ります。IndexServletを修正したのでTomcatを再起動しましょう。

http://localhost:8080/message_board/index
にアクセスしたとき、画面に「hello」が表示されていればOKです。

08

Lesson 13Chapter 9.3
newのビューを作成
NewServlet の doGet メソッドを修正します。せっかく記述したデータベースの登録処理ですが、 CreateServlet（この後作成）で記述しなおす形になります。

src/controllers/NewServlet.java

package controllers;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import models.Message;

/**
 * Servlet implementation class NewServlet
 */
@WebServlet("/new")
public class NewServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    /**
     * @see HttpServlet#HttpServlet()
     */
    public NewServlet() {
        super();
    }

    /**
     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // CSRF対策
        request.setAttribute("_token", request.getSession().getId());

        // おまじないとしてのインスタンスを生成
        request.setAttribute("message", new Message());

        RequestDispatcher rd = request.getRequestDispatcher("/WEB-INF/views/messages/new.jsp");
        rd.forward(request, response);
     }
}
request.setAttribute("_token", request.getSession().getId());の部分は CSRF と呼ばれるセキュリティへの脅威に対する対策です。

フォームから hidden 要素で送られた値とセッションに格納された値が同一であれば送信を受け付けるようにする、というものです。こうすることで、サイト外からPOST送信された投稿を拒否できます。ここではセッションIDと呼ばれるものを利用しています。

それとは別に、Message のインスタンスを生成してリクエストスコープに格納しています。これの意図は後述しますが、ここではいったん、フォームのページを表示する上での「おまじない」だと思ってください。

次にビューを作りましょう。ここで使うフォームは edit でも利用したいので、レイアウトファイルと同じように共通ファイル化しておきます。ファイル名は _form.jsp としてください。

WebContent/WEB-INF/views/messages/_form.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<label>タイトル<br />
<input type="text" name="title" value="${message.title}" />
</label>
<br /><br />
<label>メッセージ<br />
<input type="text"  name="content" value="${message.content}"/>
</label>
<br /><br />
<input type="hidden" name="_token" value="${_token}" />
<button type="submit">投稿</button>
タイトルとメッセージのテキストボックスに value="${message.title}" のような記述を入れました。

リクエストスコープの message オブジェクトからデータを参照して、入力内容の初期値として表示するようにしています。このあと作成する edit や、入力値エラーがあってフォームのページを再度表示する際に役立ちます。

ただし、リクエストスコープに message が入っていなければエラーが表示されます。NewServlet で「おまじない」として request.setAttribute("message", new Message()); を記述したのは、画面表示時のエラー回避のため、とりあえず “文字数0のデータ” をフォームに渡すためです。

この _form.jsp がフォームの共通レイアウトになります。new.jsp を作成して、 _form.jsp を取り込むように記述しましょう。

WebContent/WEB-INF/views/messages/new.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<c:import url="../layout/app.jsp">
    <c:param name="content">
        <h2>メッセージ新規作成ページ</h2>

        <form method="POST" action="${pageContext.request.contextPath}/create">
            <c:import url="_form.jsp" />
        </form>

        <p><a href="${pageContext.request.contextPath}/index">一覧に戻る</a></p>

    </c:param>
</c:import>
Tomcatを再起動して、

http://localhost:8080/message_board/new
にアクセスすることでフォーム画面が表示されます。

08_01

しかし、まだ送信先の機能は作成していないので、動作確認は CreateServlet を作成してからにしましょう。

Gitにコミットする

ここまでの状態をGitにコミットしてください。

$ git add .
$ git commit -m "Modify Index/NewServlet"
Lesson 13Chapter 10
create（挿入処理）の作成
CreateServlet を作成します。設定項目は以下の内容にしてください。以下に記載がない項目についてはデフォルトのままで構いません。

1ページ目

パッケージ名：controllers
クラス名：CreateServlet
2ページ目

URLマッピング： /CreateServlet を /create に変更する
3ページ目

doGetのチェックのみ外し、あとはそのまま
ファイルが作成できたら、以下のように doPost のメソッドに記述してください。

src/controllers/CreateServlet.java

package controllers;

import java.io.IOException;
import java.sql.Timestamp;

import javax.persistence.EntityManager;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import models.Message;
import utils.DBUtil;

/**
 * Servlet implementation class CreateServlet
 */
@WebServlet("/create")
public class CreateServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    /**
     * @see HttpServlet#HttpServlet()
     */
    public CreateServlet() {
        super();
    }

    /**
     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String _token = request.getParameter("_token");
        if(_token != null && _token.equals(request.getSession().getId())) {
            EntityManager em = DBUtil.createEntityManager();

            Message m = new Message();

            String title = request.getParameter("title");
            m.setTitle(title);

            String content = request.getParameter("content");
            m.setContent(content);

            Timestamp currentTime = new Timestamp(System.currentTimeMillis());
            m.setCreated_at(currentTime);
            m.setUpdated_at(currentTime);

            em.getTransaction().begin();
            em.persist(m);
            em.getTransaction().commit();
            em.close();

            response.sendRedirect(request.getContextPath() + "/index");
        }
    }

}
ここでは、

if(_token != null && _token.equals(request.getSession().getId())) { ... }
でCSRF対策のチェックを行っています。_token に値がセットされていなかったりセッションIDと値が異なったりしたらデータの登録ができないようにしています。

ここのチェックがtrueにならないのは、意図しない不正なページ遷移によって /create へアクセスされた場合です。悪意のあるネット利用者が勝手に投稿できないようにするための対策です。

また、データの保存部分について改めて説明しますが、id はMySQLの auto_increment の採番に任せ、title と content はフォームから入力された内容をセットします。 created_at と updated_at は、

Timestamp currentTime = new Timestamp(System.currentTimeMillis());
このように記述することで現在日時の情報を持つ日付型のオブジェクトを取得できます（Javaでは日時情報もオブジェクトで管理します）。

そのオブジェクトを2つのカラムにセットします。必要な情報をセットした Message クラスのオブジェクトを persist メソッドを使ってデータベースにセーブします。commit を忘れないようにしてください。

そして、データベースへの保存が完了したら、indexページへリダイレクト（遷移）させるようにしています。

Tomcatを再起動し、

http://localhost:8080/message_board/index
へアクセス →「新規メッセージの投稿」→ タイトルとメッセージを入力して「投稿」、までの一連の流れを試しましょう。投稿が完了すると index ページへリダイレクト（遷移）し、さきほど投稿した内容が表示されていればOKです。何件か投稿してみてください。

09

Gitにコミットする
ここまでの状態をGitにコミットしましょう。

$ git add .
$ git commit -m "Add CreateServlet.java"
Lesson 13Chapter 11
show（詳細画面）の作成
index ページのID番号に貼ったリンクをクリックすると、該当のメッセージの詳細情報を表示するページを作成します。

まずはコントローラ（サーブレット）の ShowServletを用意しましょう。操作は今までのとおりです。URLマッピングは /ShowServlet から /show へ変更し、メソッドは doGet を残して作成してください。ファイルが作成できたら、以下のように doGet を記述しましょう。

src/controllers/ShowServlet.java

package controllers;

import java.io.IOException;

import javax.persistence.EntityManager;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import models.Message;
import utils.DBUtil;

/**
 * Servlet implementation class ShowServlet
 */
@WebServlet("/show")
public class ShowServlet extends HttpServlet {
        private static final long serialVersionUID = 1L;

    /**
     * @see HttpServlet#HttpServlet()
     */
    public ShowServlet() {
        super();
    }

    /**
     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        EntityManager em = DBUtil.createEntityManager();

        // 該当のIDのメッセージ1件のみをデータベースから取得
        Message m = em.find(Message.class, Integer.parseInt(request.getParameter("id")));

        em.close();

        // メッセージデータをリクエストスコープにセットしてshow.jspを呼び出す
        request.setAttribute("message", m);

        RequestDispatcher rd = request.getRequestDispatcher("/WEB-INF/views/messages/show.jsp");
        rd.forward(request, response);
    }
}
今回は1件のみデータを取得できれば良いので、Lesson9 JDBC2の「6.4 Hibernateを使ってDBからデータを取得する」 で作成したコードと同じ em.find() メソッドを利用します。IDはURLに追記されている id から取得します。

たとえば、

http://localhost:8080/message_board/show?id=1
にアクセスすると、id が1のメッセージ情報を表示する必要があります。

クエリ・パラメータの id は request.getParameter("id") で取得できますが、注意したいのが request.getParameter() はどのようなデータもString型のデータとして取得するという特徴です。データベースの id は整数値です。そこで Interger.parseInt() メソッドを利用してString型の”1”を整数値の1に変えてから find メソッドの引数にしています。

次にビューとなる show.jsp を作成します。

WebContent/WEB-INF/views/messages/show.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt"%>
<c:import url="../layout/app.jsp">
    <c:param name="content">

        <h2>id : ${message.id} のメッセージ詳細ページ</h2>

        <p>タイトル：<c:out value="${message.title}" /></p>
        <p>メッセージ：<c:out value="${message.content}" /></p>
        <p>作成日時：<fmt:formatDate value="${message.created_at}" pattern="yyyy-MM-dd HH:mm:ss" /></p>
        <p>更新日時：<fmt:formatDate value="${message.updated_at}" pattern="yyyy-MM-dd HH:mm:ss" /></p>

        <p><a href="${pageContext.request.contextPath}/index">一覧に戻る</a></p>

    </c:param>
</c:import>
日情報は基本的にオブジェクトの形をしており、単純な文字列ではありません。

そこで <fmt:formatDate> タグで作成日時や更新日時を pattern 属性で指定した 年-月-日 時:分:秒 の形式で表示するようにしています。<fmt:formatDate> について詳細を知りたい方は 公式ドキュメントの説明 を参照してください。

ここまで作成できたら、Tomcatを再起動して、index ページから各メッセージ左側の数値に貼られたリンクをクリックし、該当のidのメッセージ詳細ページへ遷移しましょう。以下のような画面が表示されればOKです！

10

Gitにコミットする
ここまでの内容をGitにコミットしてください。

$ git add .
$ git commit -m "Add ShowServlet"
Lesson 13Chapter 12
edit（編集画面）の作成
続いて、メッセージを修正する機能を作りましょう。必要なのは edit（編集画面）と update（更新処理）のサーブレットです。

まずは edit（編集画面）から。show.jsp に edit へのリンクを貼りましょう。「一覧へ戻る」リンクの行の下に1行追加します。

WebContent/WEB-INF/views/messages/show.jsp（抜粋）

<!-- ...（中略）... -->

        <p><a href="${pageContext.request.contextPath}/index">一覧に戻る</a></p>
        <p><a href="${pageContext.request.contextPath}/edit?id=${message.id}">このメッセージを編集する</a></p>

<!-- ...（中略）... -->
EditServletをつくります。URLマッピングは /EditServlet から /edit へ変更し、メソッドは doGet を残して作成しましょう。ファイルを作成できたら、以下のように記述してください。

src/controllers/EditServlet.java

package controllers;

import java.io.IOException;

import javax.persistence.EntityManager;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import models.Message;
import utils.DBUtil;

/**
 * Servlet implementation class EditServlet
 */
@WebServlet("/edit")
public class EditServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    /**
     * @see HttpServlet#HttpServlet()
     */
    public EditServlet() {
        super();
    }

    /**
     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        EntityManager em = DBUtil.createEntityManager();

        // 該当のIDのメッセージ1件のみをデータベースから取得
        Message m = em.find(Message.class, Integer.parseInt(request.getParameter("id")));

        em.close();

        // メッセージ情報とセッションIDをリクエストスコープに登録
        request.setAttribute("message", m);
        request.setAttribute("_token", request.getSession().getId());

        // メッセージIDをセッションスコープに登録
        request.getSession().setAttribute("message_id", m.getId());

        RequestDispatcher rd = request.getRequestDispatcher("/WEB-INF/views/messages/edit.jsp");
        rd.forward(request, response);
    }
}
リクエストスコープにメッセージのIDを入れた場合、このあと作成する /update へデータを送信する際に <input type="hidden"> を使ってメッセージIDの情報をフォームに追加する必要があります。しかし今回はセッションスコープへメッセージのIDの情報を保存して、/update へ渡すことにしました。

さらに、viewになる edit.jsp を作成します。

WebContent/WEB-INF/views/messages/edit.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<c:import url="../layout/app.jsp">
    <c:param name="content">
        <h2>id : ${message.id} のメッセージ編集ページ</h2>

        <form method="POST" action="${pageContext.request.contextPath}/update">
            <c:import url="_form.jsp" />
        </form>

        <p><a href="${pageContext.request.contextPath}/index">一覧に戻る</a></p>

    </c:param>
</c:import>
_form.jsp で <input type="text" name="title" value="${message.title}" /> のように記述したため、value="${message.title}" のおかげでデータベースに保存されていたメッセージやタイトルが初期値としてテキストボックスに格納されます。

ここまでできたらTomcatを再起動した後、show ページから「このメッセージを編集する」のリンクをクリックして edit ページへ遷移し、すでに登録されたメッセージがテキストボックスに入っている画面の表示になればOKです！

11

ただし、更新処理は未実装ですので、編集フォームの送信ボタンを押してどうなるかを試すのは UpdateServlet を作成してからにしましょう。

Gitにコミットする
ここまでの内容をGitにコミットしてください。

$ git add .
$ git commit -m "Add EditServlet"
Lesson 13Chapter 13
update（更新処理）の作成
では更新処理の UpdateServletを作成します。URLマッピングは /UpdateServlet から /update へ変更し、メソッドは doPost を残して作成してください。ファイルを作成できたら、以下のように記述してください。

src/controllers/UpdateServlet.java

package controllers;

import java.io.IOException;
import java.sql.Timestamp;

import javax.persistence.EntityManager;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import models.Message;
import utils.DBUtil;

/**
 * Servlet implementation class UpdateServlet
 */
@WebServlet("/update")
public class UpdateServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    /**
     * @see HttpServlet#HttpServlet()
     */
    public UpdateServlet() {
        super();
    }

    /**
     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String _token = request.getParameter("_token");
        if(_token != null && _token.equals(request.getSession().getId())) {
            EntityManager em = DBUtil.createEntityManager();

            // セッションスコープからメッセージのIDを取得して
            // 該当のIDのメッセージ1件のみをデータベースから取得
            Message m = em.find(Message.class, (Integer)(request.getSession().getAttribute("message_id")));

            // フォームの内容を各フィールドに上書き
            String title = request.getParameter("title");
            m.setTitle(title);

            String content = request.getParameter("content");
            m.setContent(content);

            Timestamp currentTime = new Timestamp(System.currentTimeMillis());
            m.setUpdated_at(currentTime);       // 更新日時のみ上書き

            // データベースを更新
            em.getTransaction().begin();
            em.getTransaction().commit();
            em.close();

            // セッションスコープ上の不要になったデータを削除
            request.getSession().removeAttribute("message_id");

            // indexページへリダイレクト
            response.sendRedirect(request.getContextPath() + "/index");
        }
    }
}
id は EditServlet でセッションスコープに保存した message_id のデータを使います。request.getSession().getAttribute() でセッションスコープから取得したデータは汎用的な Object 型になっているため、(Integer) でキャストしています。

あとの流れは CreateServlet と同じですが、これは更新処理なので created_at は変更しないようにしています。また、データベースから取得したデータに変更をかけてコミットすれば変更が反映されるので em.persist(m); は不要です。

さらに、更新が完了した時点でセッションスコープ上のデータは要らなくなります。不要なデータをセッションスコープに残しておくのは、お行儀が悪いので、

request.getSession().removeAttribute("message_id");
で削除しています。

ここまでできたらTomcatを再起動し、index（一覧）画面や詳細画面を再度表示し、そこからメッセージの編集画面へ遷移しましょう。適当に情報を書き換え、「投稿」ボタンをクリックして /update を実行してください。indexの画面に自動で戻り、変更した内容が表示されていればOKです！

Gitにコミットする
ここまでの内容をGitにコミットしましょう。

$ git add .
$ git commit -m "Add UpdateServlet.java"
Lesson 13Chapter 14
destroy（削除処理）の作成
最後に削除機能を作成しましょう。

まず、edit.jsp に削除機能のリンクを貼ります。一覧へ戻るリンクの下に、以下の内容を追記してください。

WebContent/WEB-INF/views/messages/edit.jsp

<!-- ...（中略）... -->

        <p><a href="${pageContext.request.contextPath}/index">一覧に戻る</a></p>
        <p><a href="#" onclick="confirmDestroy();">このメッセージを削除する</a></p>
        <form method="POST" action="${pageContext.request.contextPath}/destroy">
            <input type="hidden" name="_token" value="${_token}" />
        </form>
        <script>
        function confirmDestroy() {
            if(confirm("本当に削除してよろしいですか？")) {
                document.forms[1].submit();
            }
        }
        </script>

<!-- ...（中略）... -->
削除用に /update とは別のフォームを用意しています。このフォームはJavaScriptで確認のウィンドウを表示した上で「OK」がクリックされたらフォームを送信するようにしています。

11_01

なお本コースではJavaScriptについての学習は行っていないので、詳しく知りたい方は とほほのJavaScriptリファレンス などのサイトを参照してください。

WebContent/WEB-INF/views/messages/edit.jsp（JavaScriptの部分を抜粋）

        function confirmDestroy() {
            if(confirm("本当に削除してよろしいですか？")) {
                document.forms[1].submit();
            }
        }
削除機能を実行するフォームを作ったところで、DestroyServletクラスを作ります。URLマッピングは /DestroyServlet から /destroy へ変更し、メソッドは doPostを残して作成しましょう。ファイルが作成できたら、以下のように記述してください。

src/controllers/DestroyServlet.java

package controllers;

import java.io.IOException;

import javax.persistence.EntityManager;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import models.Message;
import utils.DBUtil;

/**
 * Servlet implementation class DestroyServlet
 */
@WebServlet("/destroy")
public class DestroyServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    /**
     * @see HttpServlet#HttpServlet()
     */
    public DestroyServlet() {
        super();
    }

    /**
     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String _token = request.getParameter("_token");
        if(_token != null && _token.equals(request.getSession().getId())) {
            EntityManager em = DBUtil.createEntityManager();

            // セッションスコープからメッセージのIDを取得して
            // 該当のIDのメッセージ1件のみをデータベースから取得
            Message m = em.find(Message.class, (Integer)(request.getSession().getAttribute("message_id")));

            em.getTransaction().begin();
            em.remove(m);       // データ削除
            em.getTransaction().commit();
            em.close();

            // セッションスコープ上の不要になったデータを削除
            request.getSession().removeAttribute("message_id");

            // indexページへリダイレクト
            response.sendRedirect(request.getContextPath() + "/index");
        }
    }
}
基本的な流れは UpdateServlet と同様ですが、データベースからデータを削除する際は、em.find で取得したオブジェクトを引数に入れて em.remove(); を実行し、さらに em.getTransaction().commit(); でコミットする必要があります。

ここまでできたらTomcatを再起動し、特定のメッセージの編集ページから削除リンクをクリックし、確認のウィンドウを表示してください。そこでOKをクリックすると、一覧画面に戻り、指定した内容が削除されていることが確認できればOKです！

Gitにコミットする
ここまでの内容をGitにコミットしてください。

$ git add .
$ git commit -m "Add DestroyServlet.java"
Lesson 13Chapter 15
より良いアプリケーションにするTips
これでRESTの概念に沿ってメッセージ管理の機能をひととおり制作しました。ここで、アプリケーションの質をアップする細かい修正を行いましょう。

Lesson 13Chapter 15.1
データが無かった場合に表示内容を変える
show.jsp と edit.jsp について、該当するIDのメッセージデータが無かった場合に「お探しのデータは見つかりませんでした。」と表示させるように変更します。条件分岐をしたいので <c:choose> および <c:when> 、 <c:otherwise> を使いましょう。

復習されたい方は Lesson11 サーブレット/JSPの「12.1 主なJSTLタグまとめ」 を参照してください。

WebContent/WEB-INF/views/messages/show.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt"%>
<c:import url="../layout/app.jsp">
    <c:param name="content">
        <c:choose>
            <c:when test="${message != null}">
                <h2>id : ${message.id} のメッセージ詳細ページ</h2>

                <p>タイトル：<c:out value="${message.title}" /></p>
                <p>メッセージ：<c:out value="${message.content}" /></p>
                <p>作成日時：<fmt:formatDate value="${message.created_at}" pattern="yyyy-MM-dd HH:mm:ss" /></p>
                <p>更新日時：<fmt:formatDate value="${message.updated_at}" pattern="yyyy-MM-dd HH:mm:ss" /></p>

                <p><a href="${pageContext.request.contextPath}/index">一覧に戻る</a></p>
                <p><a href="${pageContext.request.contextPath}/edit?id=${message.id}">このメッセージを編集する</a></p>
            </c:when>
            <c:otherwise>
                <h2>お探しのデータは見つかりませんでした。</h2>
            </c:otherwise>
        </c:choose>
    </c:param>
</c:import>
WebContent/WEB-INF/views/messages/edit.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<c:import url="../layout/app.jsp">
    <c:param name="content">
        <c:choose>
            <c:when test="${message != null}">
                <h2>id : ${message.id} のメッセージ編集ページ</h2>

                <form method="POST" action="${pageContext.request.contextPath}/update">
                    <c:import url="_form.jsp" />
                </form>

                <p><a href="${pageContext.request.contextPath}/index">一覧に戻る</a></p>
                <p><a href="#" onclick="confirmDestroy();">このメッセージを削除する</a></p>
                <form method="POST" action="${pageContext.request.contextPath}/destroy">
                    <input type="hidden" name="_token" value="${_token}" />
                </form>
                <script>
                    function confirmDestroy() {
                        if(confirm("本当に削除してよろしいですか？")) {
                            document.forms[1].submit();
                        }
                    }
                </script>
            </c:when>
            <c:otherwise>
                <h2>お探しのデータは見つかりませんでした。</h2>
            </c:otherwise>
        </c:choose>
    </c:param>
</c:import>
また、EditServlet 内の、

request.getSession().setAttribute("message_id", m.getId());
の1行で、該当するIDのメッセージデータがない場合にNullPointerExceptionが出るため、例外を回避するための修正をしましょう。以下のように、該当の行を if で囲ってください。

src/controllers/EditServlet.java（該当部分のみ抜粋）

        // ...（中略）...

        // メッセージ情報とセッションIDをリクエストスコープに登録
        request.setAttribute("message", m);
        request.setAttribute("_token", request.getSession().getId());

        // メッセージデータが存在しているときのみ
        // メッセージIDをセッションスコープに登録
        if(m != null) {
            request.getSession().setAttribute("message_id", m.getId());
        }

        // ...（中略）...
Tomcatを再起動し、show や edit へアクセスして動作確認をしましょう。その際、クエリ・パラメータとなる id=? の ? を「存在していないメッセージIDの数値」にしてアクセスします。その結果「お探しのデータは見つかりませんでした」と表示されればOKです。

Gitにコミットする
ここまでの内容をGitにコミットしましょう。

$ git add .
$ git commit -m "Modify null control"
Lesson 13Chapter 15.2
画面の装飾
ここまでCSSによる画面の装飾をまったく考慮していませんでした。CSSを追加して、もう少し見栄えのよいWebページにしましょう。

app.jsp の <head> 内に以下の <link> タグ2行を追加してください。記載順は以下のとおりとしてください。また、<c:url> を利用しているので、<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %> の指定が必要です。

WebContent/WEB-INF/views/layout/app.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="UTF-8">
        <title>メッセージボード</title>
        <link rel="stylesheet" href="<c:url value='/css/reset.css' />">
        <link rel="stylesheet" href="<c:url value='/css/style.css' />">
    </head>
    <body>
        <div id="wrapper">
            <div id="header">
                <h1>メッセージボード アプリケーション</h1>
            </div>
            <div id="content">
                ${param.content}
            </div>
            <div id="footer">
                by Taro Kirameki.
            </div>
        </div>
    </body>
</html>
reset.css と style.css の2つのCSSファイルを追加します。 WebContent フォルダ直下に css フォルダを作り、新規→ファイルから reset.css と style.css のファイルを新規作成し、内容を記述してください。なお、reset.css は、Yahoo! で配布している内容 そのままですので、コピペで書き写してもらえればOKです。

WebContent/css/reset.css

@CHARSET "UTF-8";
/*
YUI 3.18.1 (build f7e7bcb)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

html{color:#000;background:#FFF}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{margin:0;padding:0}table{border-collapse:collapse;border-spacing:0}fieldset,img{border:0}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:normal}ol,ul{list-style:none}caption,th{text-align:left}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal}q:before,q:after{content:''}abbr,acronym{border:0;font-variant:normal}sup{vertical-align:text-top}sub{vertical-align:text-bottom}input,textarea,select{font-family:inherit;font-size:inherit;font-weight:inherit;*font-size:100%}legend{color:#000}#yui3-css-stamp.cssreset{display:none}
WebContent/css/style.css

@CHARSET "UTF-8";

body {
    color: #333333;
    font-family: "Hiragino Kaku Gothic Pro",Meiryo,"MS PGothic",Helvetica,Arial,sans-serif;
}

#header {
    width: 100%;
    height: 70px;
    background-color: #333333;
}

#content {
    width: 94%;
    margin-top: 15px;
    padding-left: 3%;
}

h1 {
    width: 94%;
    padding-top: 17px;
    padding-left: 3%;
    font-size: 24px;
    color: #eeeeee;
}

h2 {
    font-size: 36px;
    margin-bottom: 15px;
}

li {
    margin-top: 10px;
    margin-bottom: 10px;
}

p {
    margin-top: 15px;
    margin-bottom: 15px;
}

a {
    text-decoration: none;
    color: #24738e;
}

table, tr, th, td {
    border: 1px solid #cccccc;
}

table {
    width: 100%;
    table-layout: fixed;
}

th {
    width: 26%;
    padding: 10px 2%;
}

td {
    width: 66%;
    padding: 10px 2%;
}

button {
    font-size: 14px;
    padding: 5px 10px;
}

#footer {
    text-align: center;
}
